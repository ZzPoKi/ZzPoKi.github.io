<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Hexo</title>
    <url>/2023/11/06/hello-hexo/</url>
    <content><![CDATA[<p>hexo博客算是初步部署好了，以后就在这里写写东西吧。</p>
]]></content>
  </entry>
  <entry>
    <title>令Azure VM的公共ip开放外部访问</title>
    <url>/2023/11/18/azure-access/</url>
    <content><![CDATA[<p>对于刚创建的Azure VM（VPS）来说，由于Azure防火墙的存在，默认情况下只有少数几个端口（如SSH服务的22端口）可供外部访问使用。而要想将更多的端口开放出来，则需要额外添加入站的端口规则。</p>
<span id="more"></span>

<h2 id="1-Azure-VPS在默认情况下无法ping通的原因"><a href="#1-Azure-VPS在默认情况下无法ping通的原因" class="headerlink" title="1. Azure VPS在默认情况下无法ping通的原因"></a>1. Azure VPS在默认情况下无法ping通的原因</h2><p>通常来说，我们在对远程主机进行连通性测试时，都习惯使用ping命令，而最开始我将Azure VPS创建出来之后，首先就是遇到了Azure主机无法ping通的问题。经过了解才知道，Azure存在一道防火墙，使得ICMP协议下的数据包被阻拦，以下是官方文档的说明：</p>
<blockquote>
<p>在 Azure 中，ICMP 包无法通过防火墙和负载均衡器，所以不能直接使用 ping 来测试 Azure 中的虚拟机和服务的连通性（VPN 和 Express Route 通道中的流量不经过负载均衡器，所以只要链路上的防火墙允许 ICMP 包传递，ping 依然可用）。</p>
</blockquote>
<p>而ping实际上就是向目标主机发送一个ICMP Echo的请求数据包，然后等待目标主机返回响应数据包，重复多次来计算网络时延和丢包率的一个过程。显然由于Azure防火墙的存在，ping命令下的ICMP请求数据包被防火墙拒绝，也就解释了默认状态下为什么对Azure主机ping只会返回请求超时。</p>
<h2 id="2-自定义入站端口规则"><a href="#2-自定义入站端口规则" class="headerlink" title="2. 自定义入站端口规则"></a>2. 自定义入站端口规则</h2><p>知道Azure防护墙对外部访问的限制后，我们需要做的就是去修改其网络安全组规则。首先打开Azure VM的控制台，进入到主机资源组中的NSG配置，可以看到最后有一条”DenyAllInBound”的默认规则，它将所有的外部访问都给拒绝了，而我们需要对入站端口规则进行添加设置，把端口从防火墙中开放出来。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/azure-access/denyall.png"
                     
                ></p>
<h3 id="2-1-设定拒绝外网访问的特定端口"><a href="#2-1-设定拒绝外网访问的特定端口" class="headerlink" title="2.1 设定拒绝外网访问的特定端口"></a>2.1 设定拒绝外网访问的特定端口</h3><p>在入站安全规则的设置界面中点击添加，这里将源保持默认设定”Any”，源端口范围保持默认设定”*”即任意端口，修改目标为”Service Tag”，将目标服务标记为”Internet”，这表示限定与互联网之间的通信规则。然后修改目标端口范围，这里可以以逗号分隔的形式来定义多个目标端口，也可以设定范围。在操作上选择 “拒绝”，规则名称自定，保存修改。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/azure-access/deny.png"
                     
                ></p>
<h3 id="2-2-设定开放外部访问的端口"><a href="#2-2-设定开放外部访问的端口" class="headerlink" title="2.2 设定开放外部访问的端口"></a>2.2 设定开放外部访问的端口</h3><p>在下一优先级中，添加一条新的开放外部访问端口的规则。将源和目标均保持默认设定”Any”，可以将目标端口范围设定为”*”即任意范围，代表全部端口放开。建议以最小权限原则自定义范围，开放真正需要的端口。操作上选择 “允许”，规则名称自定，保存修改。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/azure-access/allow.png"
                     
                ></p>
<p>这样就可以将其余端口开放出来，供外部访问使用。</p>
<h2 id="3-重新进行ping测试"><a href="#3-重新进行ping测试" class="headerlink" title="3. 重新进行ping测试"></a>3. 重新进行ping测试</h2><p>最后在本地对Azure主机ip再次进行ping测试，可以看到成功连通。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/azure-access/ping.png"
                     
                ></p>
]]></content>
      <tags>
        <tag>Azure</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux命令总结之文件操作</title>
    <url>/2023/11/21/linux-file-manage/</url>
    <content><![CDATA[<p>总结一些linux系统下常用的文件操作命令，用于管理文件和系统目录。</p>
<span id="more"></span>

<h2 id="1-Linux的目录结构"><a href="#1-Linux的目录结构" class="headerlink" title="1. Linux的目录结构"></a>1. Linux的目录结构</h2><p>Linux的目录结构是层次化的树状结构，文件目录的顶层即为根目录<code>/</code>，所有文件和目录都是根目录的衍生，以子文件或者是子目录的形式被倒挂在根目录之下，构成整个linux文件系统。</p>
<pre class="mermaid">   graph TD;
    / --> bin
    / --> boot
    / --> dev
    / --> etc
    / --> 1[...]
    bin --> apt
    bin --> vim
    bin --> 2[...]
    etc --> init.d
    etc --> 3[...]
    boot --> 4[...]
    dev --> 5[...]
    1[...] --> 6[...]</pre>

<h3 id="1-1-目录功能"><a href="#1-1-目录功能" class="headerlink" title="1.1 目录功能"></a>1.1 目录功能</h3><p>根目录下的不同子目录均承担着不同的作用，通常来说根目录衍生出来的一级目录可以简单归纳为如下功能作用</p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能作用</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;bin</td>
<td>存放系统命令，均为一些可执行的二进制文件</td>
</tr>
<tr>
<td>&#x2F;boot</td>
<td>存放引导加载程序和内核镜像文件，确保系统能被正常引导启动</td>
</tr>
<tr>
<td>&#x2F;dev</td>
<td>存放系统所使用设备文件，比如硬盘分区、终端、串口等文件</td>
</tr>
<tr>
<td>&#x2F;etc</td>
<td>存放系统服务和系统全局的配置文件，如网络配置、软件包配置、用户组配置等</td>
</tr>
<tr>
<td>&#x2F;home</td>
<td>存放每个用户的主目录，也被称为家目录</td>
</tr>
<tr>
<td>&#x2F;lib</td>
<td>存放系统运行时的共享程序库，供系统不同程序共享使用</td>
</tr>
<tr>
<td>&#x2F;lost+found</td>
<td>用于临时保存丢失的文件</td>
</tr>
<tr>
<td>&#x2F;media</td>
<td>用于挂载外部可移动设备，比如一些驱动</td>
</tr>
<tr>
<td>&#x2F;mnt</td>
<td>用于手动挂载一些可移动设备</td>
</tr>
<tr>
<td>&#x2F;opt</td>
<td>用于存放一些第三方软件包和应用程序</td>
</tr>
<tr>
<td>&#x2F;proc</td>
<td>实质为由内存映射出来的虚拟目录，存放在内存中，包含当前运行进程和内核参数的动态信息</td>
</tr>
<tr>
<td>&#x2F;root</td>
<td>根用户的家目录，用于存放根用户的使用文件，只有根用户才有权限访问</td>
</tr>
<tr>
<td>&#x2F;srv</td>
<td>存放服务相关的文件和数据</td>
</tr>
<tr>
<td>&#x2F;sys</td>
<td>存放内核参数运行时的访问、驱动以及设备的相关信息</td>
</tr>
<tr>
<td>&#x2F;tmp</td>
<td>用于存放临时文件</td>
</tr>
<tr>
<td>&#x2F;usr</td>
<td>存放系统用户使用的应用程序和文件</td>
</tr>
<tr>
<td>&#x2F;var</td>
<td>存放动态变化的数据文件，比如日志文件、缓存文件等</td>
</tr>
</tbody></table>
<h2 id="2-目录切换"><a href="#2-目录切换" class="headerlink" title="2. 目录切换"></a>2. 目录切换</h2><p>在Linux系统中，切换目录的命令是<code>cd</code>命令，也就是change directory，其基本语法为：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> [切换目录路径]</span><br></pre></td></tr></table></figure></div>

<p>在所切换的目录路径中，可以是绝对路径或相对路径。比如：</p>
<p>切换到绝对路径</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/sites-available</span><br></pre></td></tr></table></figure></div>

<p>这表示将当前目录切换至以根目录为起点的&#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;上。</p>
<p>切换到相对路径</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> nginx/sites-available</span><br></pre></td></tr></table></figure></div>

<p>这表示在当前目录为&#x2F;etc的位置基础上，将目录切换至&#x2F;etc下的nginx&#x2F;sites-available上。</p>
<p>而要想将当前目录切换至上一级目录，则采用命令</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure></div>

<p>如果要切换至上上级目录，则为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../..</span><br></pre></td></tr></table></figure></div>

<p>以此类推。</p>
<p>如果要切换至&#x2F;home目录，可以使用</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure></div>

<p>或者直接使用</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br></pre></td></tr></table></figure></div>

<p>想要将当前目录切换至上一次的工作目录，可以使用</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure></div>

<h2 id="3-目录列出显示"><a href="#3-目录列出显示" class="headerlink" title="3. 目录列出显示"></a>3. 目录列出显示</h2><p>要想列出当前目录下的文件和子目录，应该使用<code>ls</code>也就是list命令，基本语法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> [选项] [文件目录]</span><br></pre></td></tr></table></figure></div>

<p>其中一些常用命令为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l <span class="comment">#以详细列表的形式列出文件和目录的权限、所有者、大小等信息</span></span><br><span class="line"><span class="built_in">ls</span> * <span class="comment">#查看当前目录的所有子目录和文件以及下一级目录中的所有子目录和文件</span></span><br><span class="line"><span class="built_in">ls</span> -a <span class="comment">#显示所有文件目录，包括隐藏文件</span></span><br><span class="line"><span class="built_in">ls</span> -t <span class="comment">#以修改时间排序显示</span></span><br><span class="line"><span class="built_in">ls</span> -R <span class="comment">#递归显示当前目录和子目录的所有内容</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>想要列出其他目录的文件和子目录，同<code>cd</code>命令一样，只需要在<code>ls</code>后添加目标路径的绝对或相对路径即可。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /home/user</span><br></pre></td></tr></table></figure></div>

<p>想要查看当前所在目录，使用命令</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure></div>

<p>而想要查看整个目录的完整树状目录结构，可以通过安装tree命令来实现。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install tree <span class="comment">#Ubuntu</span></span><br></pre></td></tr></table></figure></div>

<p>通过tree命令，即可列出某个目录的所有内容的树状结构。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tree [目录路径]</span><br></pre></td></tr></table></figure></div>

<p>同样目录路径遵循相对路径和绝对路径的原则。</p>
<h2 id="4-目录与文件的创建和删除"><a href="#4-目录与文件的创建和删除" class="headerlink" title="4. 目录与文件的创建和删除"></a>4. 目录与文件的创建和删除</h2><h3 id="4-1-目录和文件的创建"><a href="#4-1-目录和文件的创建" class="headerlink" title="4.1 目录和文件的创建"></a>4.1 目录和文件的创建</h3><p>在Linux中，想要创建一个空文件，需要使用<code>touch</code>命令，写法如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> [选项] filename <span class="comment">#选项可选，filename即为文件名</span></span><br></pre></td></tr></table></figure></div>

<p>这代表在当前目录下创建一个空文件，如果文件已存在，则更新文件的访问和修改时间。</p>
<p>想要创建多个文件，只需要以空格隔开。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> file1 file2 file3</span><br></pre></td></tr></table></figure></div>

<p>而要想创建并向文件写入内容，可以使用<code>echo</code>命令。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> your_text &gt; file.txt <span class="comment">#覆盖文件原有内容</span></span><br><span class="line"><span class="built_in">echo</span> your_text &gt;&gt; file.txt <span class="comment">#向文件原有内容进行追加</span></span><br></pre></td></tr></table></figure></div>

<p>另外也可以使用文本编辑器来创建并打开文件，比如使用vim、vi、nano这类文本编辑命令，写法为：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nano readme.md</span><br></pre></td></tr></table></figure></div>

<p>这表示创建一个名为readme.md的文件并打开进行编辑。</p>
<p>如果要创建一个新的空目录，需要使用<code>mkdir</code>命令，即make directory。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> new_dir <span class="comment">#在当前目录下创建一个新的子目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p parent_dir/child_dir <span class="comment">#即在当前目录下创建一个parent空目录，并在其中再创建一个child空目录，实现多层嵌套</span></span><br></pre></td></tr></table></figure></div>

<p>目录的创建同样遵循相对路径和绝对路径的规则，另外需要注意在Linux下的同一目录中创建的文件夹和文件名称不得重复。</p>
<h3 id="4-2-目录和文件的删除"><a href="#4-2-目录和文件的删除" class="headerlink" title="4.2 目录和文件的删除"></a>4.2 目录和文件的删除</h3><p>在Linux中删除文件，使用的是<code>rm</code>命令，即remove。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> [选项] filename</span><br></pre></td></tr></table></figure></div>

<p>同样要同时删除多个文件，只需要以空格隔开。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> file1 file2 file3</span><br></pre></td></tr></table></figure></div>

<p>其中<code>rm</code>命令的常用选项有<code>-r</code>、<code>-f</code>、<code>-i</code>、<code>-v</code>等。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -r <span class="built_in">dirname</span> <span class="comment">#递归删除指定目录及其所有内容</span></span><br><span class="line"><span class="built_in">rm</span> -f filename <span class="comment">#强制删除文件，不进行提示</span></span><br><span class="line"><span class="built_in">rm</span> -i filename <span class="comment">#在删除前和用户进行交互式确认</span></span><br><span class="line"><span class="built_in">rm</span> -v filename <span class="comment">#在删除文件时显示详细信息</span></span><br></pre></td></tr></table></figure></div>

<p>而想要删除一个空目录，则需要使用<code>rmdir</code>命令，即remove directory。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> [选项] empty_dir <span class="comment">#选项同rm命令的选项</span></span><br></pre></td></tr></table></figure></div>

<p>比如在当前目录下存在子目录结构</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">top</span><br><span class="line">└── parent</span><br><span class="line">    └── child</span><br></pre></td></tr></table></figure></div>

<p>在均为空目录的前提下，要想删除top目录及其以下所有子目录，则应该输入命令</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> -p top/parent/child</span><br></pre></td></tr></table></figure></div>

<h2 id="5-目录与文件的复制和移动"><a href="#5-目录与文件的复制和移动" class="headerlink" title="5. 目录与文件的复制和移动"></a>5. 目录与文件的复制和移动</h2><p>要将文件从一个目录复制到另一个目录，需要用到<code>cp</code>命令，即copy，写法上在当前文件路径和目标路径之间以空格隔开。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> [选项] [当前文件所在路径] [目标文件路径]</span><br></pre></td></tr></table></figure></div>

<p>比如将一个doc.txt文件从my_dir复制到new_dir中，并将文件名修改为newdoc.txt，则应该输入命令</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> my_dir/doc.txt new_dir/newdoc.txt</span><br></pre></td></tr></table></figure></div>

<p>同样，文件路径遵循绝对路径和相对路径原则。</p>
<p>而要想将整个目录连同其所有内容复制到另一个目录中，则需要使用<code>-r</code>进行递归复制</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r parent/child new_dir</span><br></pre></td></tr></table></figure></div>

<p>目录和文件的移动（剪切）和复制的操作类似，使用的是<code>mv</code>即move命令，写法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> [选项] [当前文件所在路径] [目标文件路径]</span><br></pre></td></tr></table></figure></div>

<p>同样地，要移动整个文件夹及其所有内容，需要使用<code>-r</code>进行递归移动。</p>
<p>另外如果想要在当前目录下给文件改名，也可以使用<code>mv</code>命令</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> filename new_filename</span><br></pre></td></tr></table></figure></div>

<h2 id="6-文件的打包和解压缩"><a href="#6-文件的打包和解压缩" class="headerlink" title="6. 文件的打包和解压缩"></a>6. 文件的打包和解压缩</h2><h3 id="6-1-tar命令的压缩和解压缩"><a href="#6-1-tar命令的压缩和解压缩" class="headerlink" title="6.1 tar命令的压缩和解压缩"></a>6.1 tar命令的压缩和解压缩</h3><p>要在Linux下对多个文件进行打包、解包、查看等操作，比较常用的是<code>tar</code>命令，写法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar [选项] [打包归档文件] [被打包文件...] </span><br></pre></td></tr></table></figure></div>

<p>其中<code>tar</code>命令的常用选项有</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">-c <span class="comment">#创建一个新的打包归档文件</span></span><br><span class="line">-v <span class="comment">#在打包过程中列出打包文件的详细信息</span></span><br><span class="line">-f <span class="comment">#指定打包归档文件的名称，这个选项必填</span></span><br><span class="line">-x <span class="comment">#对打包归档文件进行解包</span></span><br><span class="line">-t <span class="comment">#显示打包归档文件中的内容</span></span><br><span class="line">-u <span class="comment">#更新现有归档文件</span></span><br></pre></td></tr></table></figure></div>

<p>比如要将file1、file2、file3、file4四个文件一起打包进all_file.tar这个归档文件中，应该使用<code>-c</code>选项，可以这样写</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cvf all_file.tar file1 file2 file3 file4</span><br></pre></td></tr></table></figure></div>

<p>而这时要想查看打包归档文件all_file.tar中的内容，应该使用<code>-t</code>选项，可以这样写</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -tvf all_file.tar</span><br></pre></td></tr></table></figure></div>

<p>得到输出举例如下</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">-rw-r--r-- root/root  11888896 2023-11-27 14:42 file1</span><br><span class="line">-rw-r--r-- root/root  11888896 2023-11-27 14:44 file2</span><br><span class="line">-rw-r--r-- root/root  11888896 2023-11-27 14:44 file3</span><br><span class="line">-rw-r--r-- root/root  11888896 2023-11-27 14:44 file4</span><br></pre></td></tr></table></figure></div>

<p>而想要解包归档文件，应该使用<code>-x</code>选项，写法可以为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf all_file.tar</span><br></pre></td></tr></table></figure></div>

<p>而如果要更新归档文件，应该使用<code>-u</code>选项，比如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -uvf all_file.tar newfile</span><br></pre></td></tr></table></figure></div>

<p>这表示将newfile添加到all_file.tar归档文件中，实现归档文件的更新。</p>
<p>而要想对多个文件进行同时打包压缩，需要用到压缩工具，常见的压缩工具有gzip、bzip2、xz，这里以gzip为例，比如要将file1、file2、file3、file4四个文件一起打包进all_file.tar这个归档文件中并同时进行压缩，tar命令可以写为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cvzf all_file.tar.gz file1 file2 file3 file4</span><br></pre></td></tr></table></figure></div>

<p>其中的<code>-z</code>选项即为gzip的压缩选项，其扩展名一般是.gz。</p>
<p>这时如果要解压缩并解包.tar.gz文件，同样使用<code>-x</code>的tar命令选项即可。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf all_file.tar.gz</span><br></pre></td></tr></table></figure></div>

<h3 id="6-2-zip命令的压缩和解压缩"><a href="#6-2-zip命令的压缩和解压缩" class="headerlink" title="6.2 zip命令的压缩和解压缩"></a>6.2 zip命令的压缩和解压缩</h3><p>有些Linux系统可能并不自带zip，首先需要通过apt&#x2F;yum软件安装包工具进行安装。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install zip</span><br></pre></td></tr></table></figure></div>

<p>对于使用<code>zip</code>命令进行文件或目录压缩，其写法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">zip [选项] [压缩文件名] [被执行文件或目录]</span><br></pre></td></tr></table></figure></div>

<p>其中常用的选项有</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">-r <span class="comment">#递归压缩，在压缩目录时需要用到</span></span><br><span class="line">-d <span class="comment">#删除压缩文件中的某个文件或目录</span></span><br><span class="line">-e <span class="comment">#为压缩文件设置解压密码</span></span><br></pre></td></tr></table></figure></div>

<p>而要想在zip文件中添加新的文件或目录，其写法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">zip all_file.zip new_file/new_dir <span class="comment">#如果是添加目录的话需要添加-r选项</span></span><br></pre></td></tr></table></figure></div>

<p>对于文件的解压和查看，则需要用到<code>unzip</code>命令。</p>
<p>默认情况下使用<code>unzip</code>命令会将文件解压缩在当前目录下，要想将zip压缩文件解压缩到指定目录，需要用到<code>-d</code>选项</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">unzip all_file.zip -d path/new_dir_for_zip</span><br></pre></td></tr></table></figure></div>

<p>要想指定仅仅解压缩的特定文件，或者排除特定文件，其写法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">unzip all_file.zip thisfile.txt <span class="comment">#指定特定文件</span></span><br><span class="line">unzip all_file.zip -x excludefile.txt <span class="comment">#排除特定文件</span></span><br></pre></td></tr></table></figure></div>

<p>另外要想查看压缩包内的内容，写法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">unzip -l all_file.zip</span><br><span class="line">unzip -lv all_file.zip <span class="comment">#显示详细信息</span></span><br></pre></td></tr></table></figure></div>

<h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h2><h3 id="7-1-cat命令"><a href="#7-1-cat命令" class="headerlink" title="7.1 cat命令"></a>7.1 cat命令</h3><p>想要查看某个文件的内容，最常用的命令是<code>cat</code>命令，最简单的写法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> nginx.conf</span><br></pre></td></tr></table></figure></div>

<p>即为打开并查看nginx.conf这个文件。</p>
<p>当然<code>cat</code>也支持查看多个文件</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> file1 file2 file3</span><br></pre></td></tr></table></figure></div>

<p>比较常用的<code>cat</code>选项有<code>-n</code>、<code>-b</code>、<code>-E</code>等</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> -n file <span class="comment">#显示行号</span></span><br><span class="line"><span class="built_in">cat</span> -b file <span class="comment">#显示行号，但只对非空行进行编号，不计空行</span></span><br><span class="line"><span class="built_in">cat</span> -E file <span class="comment">#在每行的末尾标记$符号</span></span><br></pre></td></tr></table></figure></div>

<p>另外在创建文件中也可以使用<code>cat</code>，并同时输入多行内容，写法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; new_file.txt &lt;&lt; <span class="string">EOF #EOF</span>即为结束行的标记</span><br><span class="line">&gt; this is a new file</span><br><span class="line">&gt; line1 </span><br><span class="line">&gt; line2 </span><br><span class="line">&gt; line3 </span><br><span class="line">&gt; line4</span><br><span class="line">&gt; EOF <span class="comment">#输入完毕后添加EOF标记，即可保存退出</span></span><br></pre></td></tr></table></figure></div>

<h3 id="7-2-tail命令"><a href="#7-2-tail命令" class="headerlink" title="7.2 tail命令"></a>7.2 tail命令</h3><p><code>tail</code>命令通常用于查看日志文件和监控文件的实时变化，语法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> [选项] [目标文件]</span><br></pre></td></tr></table></figure></div>

<p>搭配一些常用的选项，可以这样写</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f file.txt <span class="comment">#实时显示文本内容及变化，比如日志文件的实时变化</span></span><br><span class="line"><span class="built_in">tail</span> -n 20 file.txt <span class="comment">#显示file.txt文件最后的20行内容</span></span><br><span class="line"><span class="built_in">tail</span> -c 100 file.txt <span class="comment">#显示file.txt文件最后的100个字节的内容</span></span><br></pre></td></tr></table></figure></div>

<h3 id="7-3-wc命令"><a href="#7-3-wc命令" class="headerlink" title="7.3 wc命令"></a>7.3 wc命令</h3><p><code>wc</code>命令能用来统计查看文本行数、字数、字符数的统计命令，常见用法有</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l file.txt <span class="comment">#显示文件文本的行数</span></span><br><span class="line"><span class="built_in">wc</span> -w file.txt <span class="comment">#显示文件文本的字数</span></span><br><span class="line"><span class="built_in">wc</span> -c file.txt <span class="comment">#显示文件文本的字符数</span></span><br></pre></td></tr></table></figure></div>

<p>当然<code>wc</code>命令还支持同时显示多个文件的文本信息</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l /var/log/nginx/* <span class="comment">#显示nginx目录下所有文件文本的行数</span></span><br></pre></td></tr></table></figure></div>

<h3 id="7-4-du命令"><a href="#7-4-du命令" class="headerlink" title="7.4 du命令"></a>7.4 du命令</h3><p><code>du</code>命令能用来查看文本或目录所占磁盘的空间，常见用法有</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">du</span> -s file1 file2 file3 <span class="comment">#查看多个文件的大小，一般-s是默认选项</span></span><br><span class="line"><span class="built_in">du</span> -h <span class="built_in">dir</span>/file <span class="comment">#以易读方式查看dir目录下的file文件的大小</span></span><br><span class="line"><span class="built_in">du</span> -c <span class="built_in">dir</span>/* <span class="comment">#显示dir目录下所有文件和子目录的大小，并计算出总和</span></span><br></pre></td></tr></table></figure></div>

<p>当然同其他Linux命令一样，<code>du</code>命令的选项也可以组合使用，如<code>-ch</code>、<code>-sh</code>等。</p>
<h3 id="7-5-find命令"><a href="#7-5-find命令" class="headerlink" title="7.5 find命令"></a>7.5 find命令</h3><p><code>find</code>命令能用于文件或目录的查找，语法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find [搜索范围目录] [选项] [对象]</span><br></pre></td></tr></table></figure></div>

<p>常用的选项有<code>-type</code>、<code>-name</code>、<code>-size</code>等，当然也可以组合使用，比如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /var -<span class="built_in">type</span> f -name nginx.log <span class="comment">#f代表的是文本文件类型，d则为目录类型</span></span><br></pre></td></tr></table></figure></div>

<p>这表示在&#x2F;var目录下查找名称为nginx.log的文本类型文件。</p>
<p>当然<code>find</code>命令也可以进行模糊搜索，通过和*通配符搭配的形式，比如说</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">find /var -<span class="built_in">type</span> f -name *.<span class="built_in">log</span></span><br></pre></td></tr></table></figure></div>

<p>这表示在&#x2F;var目录下查找所有以.log结尾的文本类型文件。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习之进程和资源管理</title>
    <url>/2023/12/04/linux-process-resource/</url>
    <content><![CDATA[<p>总结Linux下进程和资源相关的概念，并利用相关Linux命令对其进查看管理。</p>
<span id="more"></span>

<h2 id="1-理解进程的概念"><a href="#1-理解进程的概念" class="headerlink" title="1. 理解进程的概念"></a>1. 理解进程的概念</h2><p>在Linux中，进程是程序执行的实例，它包含了程序的代码和执行时的数据及状态，是随着程序被加载内存中运行而产生的。对于Linux系统来说进程是资源封装的单位，其占用了内存、磁盘、PID、网络、CPU等系统资源。当程序被执行产生进程，系统将自动为进程赋予一个PID，并给启动这个进程的用户予以一组有效的权限设置。</p>
<h3 id="1-1-父子进程的概念"><a href="#1-1-父子进程的概念" class="headerlink" title="1.1 父子进程的概念"></a>1.1 父子进程的概念</h3><p>父子进程指的是通过进程创建机制所产生的相关联的两个进程。在Linux系统中，父进程通过系统调用<code>fork()</code>来创建子进程，子进程会继承父进程的资源和状态，能够独立于父进程执行新的程序。</p>
<p>比如，当通过ssh连接到远程Linux系统时，通常会触发作为父进程的sshd守护进程创建一个新的sshd子进程，用作接受处理ssh客户端（如Xshell）的新请求，当ssh连接成功建立，此时sshd作为父进程将会为连接的用户创建一个bash的子进程，用于处理用户输入执行的命令，而当用户在bash shell上输入并执行命令时，bash shell又会创建一个新的子进程来负责命令的处理。这里可以同时使用多个终端进行ssh连接，然后执行不同命令，然后使用<code>pstree | grep sshd</code>来获取sshd父子进程的树状关系。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pstree | grep sshd</span><br><span class="line"></span><br><span class="line">    |-sshd-+-sshd---sshd---bash---htop</span><br><span class="line">    |      |-sshd---sshd---bash-+-grep</span><br><span class="line">    |      `-sshd---sshd---bash---tail</span><br></pre></td></tr></table></figure></div>

<p>用图表可以直观描述为</p>
<pre class="mermaid">graph LR
    sshd守护进程 --> |fork| 1[sshd子进程]
    sshd守护进程 --> |fork| 2[sshd子进程]
    sshd守护进程 --> |fork| 3[sshd子进程]
    1[sshd子进程] --> |fork| 4[bash解释器]
    4[bash解释器] --> |fork| htop命令
    2[sshd子进程] --> |fork| 5[bash解释器]
    3[sshd子进程] --> |fork| 6[bash解释器]
    5[bash解释器] --> |fork| grep命令
    6[bash解释器] --> |fork| tail命令
    6[bash解释器] --> |fork| 9[...]</pre>

<h3 id="1-2-进程的生命周期"><a href="#1-2-进程的生命周期" class="headerlink" title="1.2 进程的生命周期"></a>1.2 进程的生命周期</h3><p>正常的进程生命周期分为几个关键的阶段，主要有创建、就绪、运行、阻塞、终止五个阶段。当一个进程通过<code>fork()</code>被创建出来时，系统会为新的进程分配一个新的PID用作标识该进程，并为进程分配系统资源，完成进程的创建初始化后进入到就绪状态，此时进程的资源已经分配完成，只需要获得CPU的资源调度即可进入到运行状态。而当进程因为某些事件发生而导致无法执行时，此时进程由运行状态转为阻塞状态，阻塞状态的进程当完成资源的重新分配及请求通过后，又会被唤醒为就绪状态等待CPU资源的调度。最后当进程完成任务后，进程进入终止阶段，系统将调用<code>exit()</code>来终止进程并释放所有资源。</p>
<pre class="mermaid">graph LR
    创建阶段 --> |初始化完成| 就绪阶段
    就绪阶段 --> |CPU调度| 运行阶段
    运行阶段 --> |事件中断| 阻塞阶段
    阻塞阶段 --> |重新唤醒| 就绪阶段
    运行阶段 --> |任务完成| 终止阶段
    终止阶段 --> |释放资源| 资源回收</pre>

<h3 id="1-3-孤儿进程和僵尸进程"><a href="#1-3-孤儿进程和僵尸进程" class="headerlink" title="1.3 孤儿进程和僵尸进程"></a>1.3 孤儿进程和僵尸进程</h3><ul>
<li><strong>孤儿进程</strong></li>
</ul>
<p>孤儿进程，即当父进程提前终止时，子进程仍处在运行或者其他阶段时的进程状态，此时子进程将会成为孤儿进程。为了避免子进程在执行完成后无法释放资源而导致非正常终止的情况发生，在Linux系统中，孤儿进程通常会被PID为1的init系统守护进程接管充当其父进程，直到子进程任务执行完成将资源正常释放。</p>
<pre class="mermaid">graph TD
    init进程 --> 父进程
    父进程 --> 子进程
    父进程 --> |提前终止| 资源回收
    init进程 --> |接管| 子进程
    子进程 --> |执行完成| 资源回收</pre>

<ul>
<li><strong>僵尸进程</strong></li>
</ul>
<p>正常情况下，当子进程执行完成后，通过调用<code>exit()</code>进入到终止状态，然后让父进程进行<code>wait()</code>的系统调用来获取子进程的终止状态，一旦子进程的终止状态被系统调用读取，子进程的资源也就被系统回收，其PID和相关信息也将从进程表中移除。而如果当子进程执行完成进入终止状态，父进程却没有及时回收子进程的终止状态，此时子进程的程序资源虽然已经被系统回收，但仍然滞停在终止状态，占用着进程表的PID和信息描述等资源，这种状态就叫做僵尸进程状态。</p>
<pre class="mermaid">graph TD   
    父进程初始化 ----> 父进程
    父进程 ---> 父进程终止
    父进程 --> |fork| 子进程初始化
    subgraph child_process 
    子进程初始化 --> 子进程
    子进程 ---> |exit| 子进程终止
    end
    子进程终止 --> |wait| 父进程
    子进程终止 ----> |父进程未回收| 僵尸进程</pre>

<h2 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2. 进程管理"></a>2. 进程管理</h2><p>在Linux中，要想查看各进程信息和状态，常用的是<code>ps</code>命令，即process status，能够显示当前运行在系统中的进程快照，常用选项有<code>e</code>、<code>-f</code>、<code>-l</code>等。比如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef <span class="comment">#以完整格式显示当前所有进程的信息</span></span><br><span class="line">ps -l <span class="comment">#以长格式显示进程信息</span></span><br><span class="line">ps -u username <span class="comment">#查看指定用户的进程信息</span></span><br><span class="line">ps aux <span class="comment">#类似于ps -ef，显示风格不同</span></span><br></pre></td></tr></table></figure></div>

<p>比如要获取nginx进程的详细状态信息，可以结合<code>grep</code>执行</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx </span><br></pre></td></tr></table></figure></div>

<p>得到返回</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">root      137746       1  0 11:34 ?        00:00:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">www-data  137747  137746  0 11:34 ?        00:00:00 nginx: worker process</span><br><span class="line">azureus+  138618  138466  0 14:31 pts/0    00:00:00 grep --color=auto nginx</span><br><span class="line"></span><br><span class="line">分别对应</span><br><span class="line"></span><br><span class="line">用户 进程PID 父进程PPID CPU使用率 进程启动时间 关联终端 累计使用CPU时间 进程命令</span><br></pre></td></tr></table></figure></div>

<p>而想要结束进程，可以使用<code>kill</code>或<code>pkill</code>，并搭配一些信号参数来实现。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> PID <span class="comment">#通过PID来杀死进程</span></span><br><span class="line">pkill process_name <span class="comment">#通过进程名来杀死进程</span></span><br></pre></td></tr></table></figure></div>

<p>一些常用的信号参数有</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">-15 <span class="comment">#默认参数，令进程正常终止</span></span><br><span class="line">-9 <span class="comment">#强制终止进程</span></span><br><span class="line">-1 <span class="comment">#挂起信号，令进程重新加载配置文件或重启</span></span><br></pre></td></tr></table></figure></div>

<p>另外还可以使用一些常用的命令和符号对进程进行前后台管理</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> <span class="built_in">command</span> &amp; <span class="comment">#令command命令在后台运行，而且不受终端关闭的影响</span></span><br><span class="line"><span class="built_in">fg</span> %[<span class="built_in">jobs</span> <span class="built_in">id</span>] <span class="comment">#将后台进程转到前台，注意不是PID</span></span><br><span class="line"><span class="built_in">bg</span> %[<span class="built_in">jobs</span> <span class="built_in">id</span>] <span class="comment">#将前台进程转到后台，注意不是PID</span></span><br><span class="line"><span class="built_in">jobs</span> -l <span class="comment">#查看后台进程的状态信息</span></span><br></pre></td></tr></table></figure></div>

<h2 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3. 资源管理"></a>3. 资源管理</h2><h3 id="3-1-实时整体资源监视"><a href="#3-1-实时整体资源监视" class="headerlink" title="3.1 实时整体资源监视"></a>3.1 实时整体资源监视</h3><p>如果要查看系统整体的实时资源情况，如CPU实时利用率，内存使用情况，实时进程列表等状态，可以输入<code>top</code>来进行快速了解，<code>top</code>能提供一个交互式的界面供用户查看和和过滤显示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/linux-process-resource/top.png"
                     
                ></p>
<p>这里首先可以看到当前时间和登录的用户数，后面的<code>load average: 0.00, 0.01, 0.00</code>分别代表在一分钟内、五分钟内、十五分钟内系统的平均负载。然后是实时任务数量，包括各状态（运行中、休眠、终止、僵尸状态）任务的显示。而%Cpu(s)即为CPU使用率的详细信息。接下来分别是内存和交换空间（与磁盘空间交换而来的虚拟内存）的实时信息，如内存总量、空闲内存情况、已使用空间等。最后是实时进程的详细信息，包括PID、启动用户、占用内存、使用CPU的百分比、累计占用CPU的时间等。</p>
<p>此外还有如<code>htop</code>和<code>glances</code>这类类似于<code>top</code>的实时资源监视工具，同样可以直观地查看各系统资源的使用状况。</p>
<ul>
<li><p><strong>htop</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/linux-process-resource/htop.png"
                     
                ></p>
</li>
<li><p><strong>glances</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/linux-process-resource/glances.png"
                     
                ></p>
</li>
</ul>
<h3 id="3-2-瞬时资源信息查看"><a href="#3-2-瞬时资源信息查看" class="headerlink" title="3.2 瞬时资源信息查看"></a>3.2 瞬时资源信息查看</h3><ul>
<li><strong>CPU资源信息</strong></li>
</ul>
<p>要想查看CPU的详细架构和配置信息，可以使用<code>lscpu</code>命令，能够得到CPU架构型号、总核数、时钟频率等参数。</p>
<p>而<code>uptime</code>能用于查看系统运行状态和平均负载，得到返回结果例如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:34:23 up 14 days, 18:22,  2 users,  load average: 0.43, 0.11, 0.04</span><br><span class="line"></span><br><span class="line">当前时间 运行时间 当前登录用户数 平均负载 </span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>内存资源信息</strong></li>
</ul>
<p>如果要查看内存相关信息，可以选择<code>free</code>命令，搭配一些常用的选项<code>-h</code>、<code>-m</code>、<code>-s</code>等，例如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ free -hs 5 <span class="comment">#以五秒为间隔输出当前的内存瞬时状态，并以易读状态显示 </span></span><br></pre></td></tr></table></figure></div>

<p>得到返回类似于<code>top</code>下的内存信息</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           884Mi       343Mi        71Mi       3.0Mi       469Mi       360Mi</span><br><span class="line">Swap:             0B          0B          0B</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>磁盘资源信息</strong></li>
</ul>
<p>通过使用<code>df</code>命令搭配一些常用选项可以查看到文件系统的磁盘空间的使用情况</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h <span class="comment">#以易读方式显示磁盘使用情况</span></span><br></pre></td></tr></table></figure></div>

<p>以其中一行为例，得到返回结果如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/root        62G  3.5G   59G   6% /</span><br></pre></td></tr></table></figure></div>

<p>这表示文件系统为<code>/dev/root</code>的根文件系统，总容量为62GB，已使用空间为3.5GB，剩余可用空间为59GB，空间利用率为6%，文件系统的挂载点为<code>/</code>即根目录。</p>
<p>另外还可以使用<code>lsblk</code>来树状显示磁盘的块设备和分区的整体结构信息，得到返回结果如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME    MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">loop0     7:0    0  63.5M  1 loop /snap/core20/2015</span><br><span class="line">loop1     7:1    0 111.9M  1 loop /snap/lxd/24322</span><br><span class="line">loop2     7:2    0  40.9M  1 loop /snap/snapd/20290</span><br><span class="line">sda       8:0    0    64G  0 disk </span><br><span class="line">├─sda1    8:1    0  63.9G  0 part /</span><br><span class="line">├─sda14   8:14   0     4M  0 part </span><br><span class="line">└─sda15   8:15   0   106M  0 part /boot/efi</span><br><span class="line">sdb       8:16   0     4G  0 disk </span><br><span class="line">└─sdb1    8:17   0     4G  0 part /mnt</span><br><span class="line">sr0      11:0    1   628K  0 rom  </span><br></pre></td></tr></table></figure></div>

<p>返回信息包括了设备名，主次设备号，是否可读写和可移动，总容量大小，设备类型，挂载点这些信息。可以知道其中<code>sda</code>的<code>disk</code>即为磁盘类型，其下分别有三个磁盘分区，而<code>sr0</code>为<code>rom</code>类型的只读光驱存储器。</p>
<ul>
<li><strong>网络资源信息</strong></li>
</ul>
<p>可以采用<code>netstat</code>或<code>ss</code>来显示系统网络状态信息，比如执行</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tunlp</span><br></pre></td></tr></table></figure></div>

<p>这表示查看当前所有的TCP和UDP网络连接，以数字形式显示ip地址和端口及端口监听状态，并将每个和连接相关的进程及其PID显示出来。得到结果如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name  </span><br><span class="line">tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      176089/nginx: maste </span><br><span class="line">udp        0      0 127.0.0.53:53           0.0.0.0:*                           47883/systemd-resol </span><br></pre></td></tr></table></figure></div>














]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>进程管理</tag>
        <tag>资源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令总结之用户权限管理</title>
    <url>/2023/11/30/linux-users-manage/</url>
    <content><![CDATA[<p>总结一下Linux系统下用户和权限的概念，以及相关命令的使用。</p>
<span id="more"></span>

<h2 id="1-用户和权限的概念"><a href="#1-用户和权限的概念" class="headerlink" title="1. 用户和权限的概念"></a>1. 用户和权限的概念</h2><p>Linux是一个多用户的系统，这点与Windows不同，它允许多个使用者以不同类型和不同权限的用户身份同时登录主机，共同分配主机的资源，由此便引出了用户和用户组以及相关权限的概念。</p>
<h3 id="1-1-用户和用户组"><a href="#1-1-用户和用户组" class="headerlink" title="1.1 用户和用户组"></a>1.1 用户和用户组</h3><p>由于Linux是多用户系统，不同用户对应不同文件的权限管理是必然要考虑的问题。就比如在同一个系统中，A用户的文件只能由A用户修改查看，而其他人想要修改A用户的个人文件则会被禁止，这也就保证了每个用户都能有单独的权限空间，也就避免了文件管理越界所导致的权限混乱。由此从文件权限角度出发，就引出了三个权限对象：<strong>用户</strong>、<strong>用户组</strong>、<strong>其他人</strong>。</p>
<ul>
<li><strong>用户</strong></li>
</ul>
<p>用户也就是文件的创建者和所有者，对文件拥有最高权限，只有用户才可以将文件的权限进行开放出来，允许其他人对文件进行查看、修改、执行操作。而如果用户想要将文件仅对部分人权限开放，此时仅仅区分用户和其他人显然不能满足需求，这也就出现了用户组这一概念。</p>
<ul>
<li><strong>用户组</strong></li>
</ul>
<p>如果用户想要将文件权限仅仅对部分人开放而对其他人关闭，这时候只要将这部分人划入用户即文件所有者所在的同一用户组，用户在组内开放权限即可。同样用户能对组内成员进行权限管理，允许组内成员对文件进行查看、执行、修改不同权限的操作，这样既能保证组内的资源共享，又能对外保证用户组的资源私有。</p>
<p>需要知道用户组分为主组和附加组，当一个用户被创建出来时，系统会默认创建出来一个和用户名相同（可以修改）的主组，也称为初始组。每个用户有且只能归属于一个主组。除了主组以外，用户还能加入多个附加组，享受多个用户组的权限，需要注意用户在附加组内能够被直接移除，附加组并不会受到影响。</p>
<ul>
<li><strong>其他人</strong></li>
</ul>
<p>其他人也就是除了用户和用户组成员以外的外部成员，通常得到的权限最低。</p>
<h3 id="1-2-root用户"><a href="#1-2-root用户" class="headerlink" title="1.2 root用户"></a>1.2 root用户</h3><p>root用户在Linux系统中属于是拥有最高权限的超级用户，拥有对系统内几乎所有资源的权限，可以执行几乎任何操作。默认情况下只有admin组和sudo组成员才能执行<code>sudo</code>命令来得到root权限进行操作，而sudoers的信息存放在&#x2F;etc&#x2F;sudoers 文件中。打开文件可以看到</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root	ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"># Members of the admin group may gain root privileges</span><br><span class="line">%admin ALL=(ALL) ALL</span><br><span class="line"></span><br><span class="line"># Allow members of group sudo to execute any command</span><br><span class="line">%sudo	ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure></div>

<p>这说明root用户拥有所有的权限，而admin组和sudo组的成员可以执行<code>sudo</code>命令来获取root权限。</p>
<p>其中的<code>ALL=(ALL:ALL) ALL</code>分别对应</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">主机名=(用户身份:用户身份所在用户组) 可执行命令</span><br></pre></td></tr></table></figure></div>

<p>要想让某个用户获得sudo权限，可以让用户加入admin组或sudo组，也可以在root下手动添加用户的sudo信息，比如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root	ALL=(ALL:ALL) ALL</span><br><span class="line">sudouser ALL=(ALL) ALL</span><br></pre></td></tr></table></figure></div>

<p>此时新添加进sudo规则中的sudouser用户就拥有了sudo执行权限。</p>
<h3 id="1-3-用户和用户组的相关配置文件"><a href="#1-3-用户和用户组的相关配置文件" class="headerlink" title="1.3 用户和用户组的相关配置文件"></a>1.3 用户和用户组的相关配置文件</h3><p>用户信息文件：&#x2F;etc&#x2F;passwd</p>
<p>用户组信息文件：&#x2F;etc&#x2F;group</p>
<p>用户密码信息：&#x2F;etc&#x2F;shadow</p>
<p>用户组密码信息：&#x2F;etc&#x2F;gshadow</p>
<p>需要知道用户和用户组的管理都需要在root权限下进行。</p>
<h2 id="2-用户组管理"><a href="#2-用户组管理" class="headerlink" title="2. 用户组管理"></a>2. 用户组管理</h2><p>Linux将用户组相关的信息存放在&#x2F;etc&#x2F;group中，每一行的储存格式为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">examplegroup:x:1100:user1,user2 #附加组</span><br><span class="line">#用户组名称:用户组密码占位符:用户组GID:用户组所包含的用户</span><br><span class="line"></span><br><span class="line">newuser:x:1001: #newuser归属的主组</span><br><span class="line">#用户组名称:用户组密码占位符:用户组GID</span><br></pre></td></tr></table></figure></div>

<p>要想添加用户组，需要使用<code>groupadd</code>命令，写法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd [选项] [用户组名称]</span><br></pre></td></tr></table></figure></div>

<p>比如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd -g 2000 newgroup <span class="comment">#创建一个名为newgroup的用户组，并指定组ID即GID为2000</span></span><br><span class="line">groupadd -r newgroup <span class="comment">#创建一个系统内（GID小于1000）的用户组</span></span><br></pre></td></tr></table></figure></div>

<p>而要想修改用户组的名称或者GID等属性，需要用到<code>groupmod</code>命令，写法同样为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">groupmod [选项] [用户组名称]</span><br></pre></td></tr></table></figure></div>

<p>比如要修改newgroup组的GID和名称，可以这样写</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd -n mygroup -g 1500 newgroup <span class="comment">#将用户组名称修改为mygroup，GID修改为1500</span></span><br></pre></td></tr></table></figure></div>

<p>如果要删除用户组，则需要使用<code>groupdel</code>命令，比如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">groupdel mygroup <span class="comment">#删除mygroup用户组</span></span><br></pre></td></tr></table></figure></div>

<p>要想查看某个用户所属的用户组，应该使用<code>groups</code>命令，例如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">groups</span> linuxuser</span><br></pre></td></tr></table></figure></div>

<p>能得到返回结果</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">linuxuser : linuxuser admin sudo mygroup ... <span class="comment">#冒号后面即为用户所属的所有用户组</span></span><br></pre></td></tr></table></figure></div>

<h2 id="3-用户管理"><a href="#3-用户管理" class="headerlink" title="3. 用户管理"></a>3. 用户管理</h2><p>Linux将用户信息相关信息存放在&#x2F;etc&#x2F;passwd文件中，每一行的存储格式为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">serveruser:x:1000:1000:Ubuntu:/home/serveruser:/bin/bash</span><br><span class="line">#用户名:用户密码占位符:用户uid:用户主组GID:用户家目录:用户所使用的解释器</span><br></pre></td></tr></table></figure></div>

<p>如果要给系统添加用户，需要使用<code>useradd</code>命令，写法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">useradd [选项] [用户名]</span><br></pre></td></tr></table></figure></div>

<p>一些常用的选项有</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">-g <span class="comment">#为新增用户指定主组，默认情况下在用户被创建出来时会被自动归属到和用户同名的用户组中</span></span><br><span class="line">-G <span class="comment">#为新增用户指定加入的附加组</span></span><br><span class="line">-u <span class="comment">#为新增用户指定uid即用户id，默认从1000开始往下排序</span></span><br><span class="line">-m <span class="comment">#为新增用户创建一个在/home下的家目录</span></span><br><span class="line">-s <span class="comment">#指定新增用户的shell解释器</span></span><br></pre></td></tr></table></figure></div>

<p>比如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个名为devuser的用户，为其添加家目录，并将其归属到devgroup组中</span></span><br><span class="line">useradd -G devgroup -m devuser </span><br><span class="line"><span class="comment">#此时得到用户信息可以为</span></span><br><span class="line">uid=1002(devuser) gid=1002(devuser) <span class="built_in">groups</span>=1002(devuser),1500(devgroup)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个名为devuser的用户，为其添加家目录，并将其主组指定为devgroup</span></span><br><span class="line">useradd -g devgroup -m devuser</span><br><span class="line"><span class="comment">#此时得到用户信息应为</span></span><br><span class="line">uid=1003(devuser) gid=1003(devuser) <span class="built_in">groups</span>=1003(devuser)</span><br></pre></td></tr></table></figure></div>

<p>而要给用户设置密码，一般是单独使用<code>passwd</code>命令</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">passwd user</span><br></pre></td></tr></table></figure></div>

<p>然后根据提示输入两次新用户的密码进行确认。</p>
<p>要想修改用户属性，应该使用<code>usermod</code>命令，写法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">usermod [选项] [用户对象]</span><br></pre></td></tr></table></figure></div>

<p>常见用法有</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -l new_username old_username <span class="comment">#修改用户名</span></span><br><span class="line">usermod -u new_uid username <span class="comment">#修改用户uid</span></span><br><span class="line">usermod -g new_primary_group username <span class="comment">#为用户修改主组</span></span><br><span class="line">usermod -G new_primary_group username <span class="comment">#为用户指定附加组，注意这会覆盖先前指定的附加组</span></span><br><span class="line">usermod -G group1,group2,group3 username <span class="comment">#为用户指定多个组，用逗号隔开</span></span><br><span class="line">usermod -aG additional_group username <span class="comment">#将用户添加到一个新的附加组，-a表示追加</span></span><br></pre></td></tr></table></figure></div>

<p>要将用户从某个用户组中移除，还可以使用<code>gpasswd</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gpasswd -d username groupname </span><br></pre></td></tr></table></figure></div>

<p>而要想删除用户，只需要执行<code>userdel</code>命令即可</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">userdel del_user <span class="comment">#删除用户del_user</span></span><br><span class="line">userdel -rf del_user <span class="comment">#强制删除用户，并移除其家目录</span></span><br></pre></td></tr></table></figure></div>

<p>其他一些用户状态查看命令</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span> username <span class="comment">#查看指定用户的详细信息</span></span><br><span class="line"><span class="built_in">whoami</span> <span class="comment">#显示当前登录用户</span></span><br><span class="line"><span class="built_in">who</span> <span class="comment">#显示已登录用户终端信息</span></span><br><span class="line">w <span class="comment">#显示已登录用户的进程负载信息</span></span><br><span class="line">last <span class="comment">#显示近期登录的终端记录</span></span><br><span class="line">lastlog <span class="comment">#显示用户的登录记录</span></span><br></pre></td></tr></table></figure></div>

<h2 id="4-权限管理"><a href="#4-权限管理" class="headerlink" title="4. 权限管理"></a>4. 权限管理</h2><h3 id="4-1-理解文件的权限"><a href="#4-1-理解文件的权限" class="headerlink" title="4.1 理解文件的权限"></a>4.1 理解文件的权限</h3><p>在Linux中，文件的操作权限被分为读取（read）、写入（write）、执行（execute），即对应r、w、x，而在操作者上又分为用户（user）、用户组（group）、其他人（others），即对应u、g、o。我们可以通过<code>ls -lh</code>命令来查看文件或目录的详细属性和权限信息，例如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -lh nginx</span><br><span class="line"><span class="comment">#得到返回</span></span><br><span class="line">-rwxr-xr-x 1 root root 1.2M May 31  2023 nginx</span><br></pre></td></tr></table></figure></div>

<p>在上述返回信息中，<code>-rwxr-xr-x</code>代表文件的权限，第一个<code>-</code>代表文件类型，此处为普通文件。接着<code>rwx</code>代表用户权限，表示用户对文件有读取、写入、执行的操作权限，之后<code>r-x</code>代表用户组权限，最后<code>r-x</code>代表其他人权限。</p>
<p>接下来是文件的所属信息，第一个<code>root</code>代表文件属于root用户，第二个<code>root</code>代表文件属于root组。</p>
<p>其他信息如权限信息后的<code>1</code>代表文件硬链接数量，<code>1.2M</code>即为文件的大小等。</p>
<h3 id="4-2-修改文件和目录的权限"><a href="#4-2-修改文件和目录的权限" class="headerlink" title="4.2 修改文件和目录的权限"></a>4.2 修改文件和目录的权限</h3><p>要想修改文件或目录的权限，应该使用<code>chmod</code>命令，来更改文件的读取、写入、执行权限，以及目录的列出、创建、删除权限，权限的修改分为符号表示法和数字表示法。</p>
<p>在符号表示法中，以<code>u</code>、<code>g</code>、<code>o</code>、<code>a</code>来分别代表用户、用户组、其他人、所有用户四种不同用户类型，并使用<code>+</code>、<code>-</code>、<code>=</code>符号来增加或移除权限，比如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u=rwx file.txt <span class="comment">#令用户拥有对file.txt文件的读取、写入、执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> g=r-x file.txt <span class="comment">#令用户组成员对file.txt文件拥有读取和执行的权限</span></span><br><span class="line"><span class="built_in">chmod</span> a+r file。txt <span class="comment">#令所有人对文件file.txt都获得对文件的读取权限</span></span><br><span class="line"><span class="built_in">chmod</span> o-x file.txt <span class="comment">#令其他人对文件file.txt失去执行的权限</span></span><br></pre></td></tr></table></figure></div>

<p>而在数字表示法中，数字和权限的对应关系为</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>数字</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>4</td>
</tr>
<tr>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>x</td>
<td>1</td>
</tr>
</tbody></table>
<p>将数字相加，即可得到相应的权限组合，比如7&#x3D;4+2+1，代表具有读取、写入、执行的权限，5&#x3D;4+1，代表具有读取、执行权限，因此写法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 750 file.txt <span class="comment">#数字7、5、0分别对应用户、用户组、其他人所拥有的权限</span></span><br><span class="line"><span class="built_in">chmod</span> 777 file.txt <span class="comment">#表示对所有人都开放最大权限</span></span><br></pre></td></tr></table></figure></div>

<p>而要想递归修改目录的权限，则应该添加<code>-R</code>选项，这能够为指定目录及其所有子目录和文件修改权限配置。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 755 mydir</span><br></pre></td></tr></table></figure></div>

<h3 id="4-3-修改文件和目录的所属"><a href="#4-3-修改文件和目录的所属" class="headerlink" title="4.3 修改文件和目录的所属"></a>4.3 修改文件和目录的所属</h3><p>要修改文件的所属，应该使用<code>chown</code>命令，写法为</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> [选项] 修改用户:修改组 文件或目录名</span><br></pre></td></tr></table></figure></div>

<p>比如</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> newuser:newgroup file.txt <span class="comment">#这表示将文件file.txt的所属用户修改为newuser，所属组修改为newgroup</span></span><br></pre></td></tr></table></figure></div>

<p>而要想给某个目录以及其所有内容修改权限，同样需要用到<code>-R</code>递归选项</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R newuser:newgroup mydir </span><br></pre></td></tr></table></figure></div>

<p>另外还可以使用<code>chgrp</code>命令来修改文件目录的所属组</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> newgroup file.txt <span class="comment">#将文件的所属组修改为newgroup</span></span><br></pre></td></tr></table></figure></div>

<p>同样也可以添加<code>-R</code>选项来进行递归修改</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> newgroup mydir </span><br></pre></td></tr></table></figure></div>

<p>需要注意无论是<code>chown</code>还是<code>chgrp</code>命令都需要相关权限才能执行，一般是root用户或文件的所属者才能操作。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>用户权限</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown的常用语法 I</title>
    <url>/2023/11/10/markdown-1/</url>
    <content><![CDATA[<p>markdown是一种轻量级的标记语言，它可以基于纯文本的形式来对文档进行编辑和修改。这里展示一些markdown的常用语法，方便个人在hexo博客下撰写自己的文章。</p>
<span id="more"></span>

<h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><p>如果要在文章中创建标题，应该在标题文字前面添加上对应标题级别的井号<code>#</code>，井号数量从一个到六个分别对应一级到六级标题。比如要创建一个二级标题和四级标题，则对应的markdown写法为：</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br></pre></td></tr></table></figure></div>

<p>呈现出来的效果即为：</p>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>另外，markdown还支持使用<code>-</code>和<code>=</code>号来进行标题标识。通过在目标文本下添加任意数量的<code>-</code>或<code>=</code>号，便能够分别标识出对应文本的二级或一级标题。写法举例：</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">一级标题</span></span><br><span class="line"><span class="section">====</span></span><br><span class="line"><span class="section">二级标题</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></div>

<p>呈现出来的效果即为：</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h2 id="2-段落和换行"><a href="#2-段落和换行" class="headerlink" title="2. 段落和换行"></a>2. 段落和换行</h2><p>要创建新的段落，可以选择在段落之间空一行或多行来进行换行，当然也可以通过在前一行的末尾添加两个或多个空格，然后回车来实现换行。</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">第一段</span><br><span class="line"></span><br><span class="line">第二段</span><br></pre></td></tr></table></figure></div>

<h2 id="3-粗体和斜体"><a href="#3-粗体和斜体" class="headerlink" title="3. 粗体和斜体"></a>3. 粗体和斜体</h2><h3 id="3-1-粗体"><a href="#3-1-粗体" class="headerlink" title="3.1 粗体"></a>3.1 粗体</h3><p>如果要对文本中的重点词进行加粗，需要在加粗文本前后各添加<strong>两个</strong>星号<code>**</code>或下划线<code>_</code>，但下划线在加粗相连单词或短语的中间部分时并不兼容，所以在文本加粗上应该尽量使用星号<code>*</code>进行加粗。</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一段<span class="strong">**粗体文本**</span>。</span><br></pre></td></tr></table></figure></div>

<p>效果如下：</p>
<p>这是一段<strong>粗体文本</strong>。</p>
<h3 id="3-2-斜体"><a href="#3-2-斜体" class="headerlink" title="3.2 斜体"></a>3.2 斜体</h3><p>如果要让某段文本斜体化，和加粗文本类似，需要在斜体文本前后各添加<strong>一个</strong>星号<code>*</code>或下划线<code>_</code>，同样考虑到兼容性的问题，在文本斜体化时还是尽量使用星号<code>*</code>来实现。</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">He is a <span class="emphasis">*gentleman*</span>.</span><br></pre></td></tr></table></figure></div>

<p>效果如下：</p>
<p>He is a <em>gentleman</em>.</p>
<p>另外，如果要使目标文本同时被加粗和斜体化，则需要在文本前后各添加<strong>三个</strong>星号<code>***</code>。</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个<span class="strong">**<span class="emphasis">*重点词*</span>**</span>。</span><br></pre></td></tr></table></figure></div>
<p>效果如下：</p>
<p>这是一个<em><strong>重点词</strong></em>。</p>
<h2 id="4-创建引用"><a href="#4-创建引用" class="headerlink" title="4. 创建引用"></a>4. 创建引用</h2><p>要想创建引用，只需要添加一个<code>&gt;</code>号在被引用文本前。同样被引用文本间在换行时仍然遵循隔行或空格换行的规则。</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一段被引用文本</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; 这是另一段被引用文本</span></span><br></pre></td></tr></table></figure></div>

<p>效果如下：</p>
<blockquote>
<p>这是一段被引用文本</p>
<p>这是另一段被引用文本</p>
</blockquote>
<p>另外文本也可以被多层嵌套引用，只需要在被嵌套引用的文本前多添加一个<code>&gt;</code>即可。</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是主要引用内容</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt;&gt; 这是附带引用内容</span></span><br></pre></td></tr></table></figure></div>

<p>效果如下：</p>
<blockquote>
<p>这是主要引用内容</p>
<blockquote>
<p>这是附带引用内容</p>
</blockquote>
</blockquote>
<h2 id="5-列表"><a href="#5-列表" class="headerlink" title="5. 列表"></a>5. 列表</h2><h3 id="5-1-有序列表"><a href="#5-1-有序列表" class="headerlink" title="5.1 有序列表"></a>5.1 有序列表</h3><p>想要创建有序列表，需要在每个列表项前添加一个数字加一个英文句点<code>.</code>，并以数字1作为列表的起始。</p>
<p>虽然说markdown在语法上允许以1为起始点后的列表项数可以取任意数，但这里建议编写有序列表时还是尽量让列表数按顺序排列，与呈现效果一致。</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一点</span><br><span class="line"><span class="bullet">2.</span> 第二点</span><br><span class="line"><span class="bullet">3.</span> 第三点</span><br><span class="line"><span class="bullet">4.</span> 第四点</span><br></pre></td></tr></table></figure></div>

<p>效果如下：</p>
<ol>
<li>第一点</li>
<li>第二点 </li>
<li>第三点</li>
<li>第四点</li>
</ol>
<h3 id="5-2-无序列表"><a href="#5-2-无序列表" class="headerlink" title="5.2 无序列表"></a>5.2 无序列表</h3><p>如果要创建无序列表，需要在每个列表项前添加一个加号<code>+</code>、减号<code>-</code>或者星号<code>*</code>。同时利用缩进可以实现无序列表的嵌套。</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 文章背景</span><br><span class="line"><span class="bullet">-</span> 文章开头</span><br><span class="line"><span class="bullet">-</span> 文章正文</span><br><span class="line"><span class="bullet">-</span> 文章总结</span><br><span class="line"><span class="bullet">    -</span> 拓展内容</span><br></pre></td></tr></table></figure></div>

<p>效果如下：</p>
<ul>
<li>文章背景</li>
<li>文章开头</li>
<li>文章正文</li>
<li>文章总结<ul>
<li>拓展内容</li>
</ul>
</li>
</ul>
<hr>
<p>下一篇文章：<a href="/2023/11/11/markdown-2">Markdown的常用语法 II</a></p>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown的常用语法 II</title>
    <url>/2023/11/11/markdown-2/</url>
    <content><![CDATA[<p>上一篇文章：<a href="/2023/11/10/markdown-1">Markdown的常用语法 I</a></p>
<span id="more"></span>

<h2 id="1-代码表示"><a href="#1-代码表示" class="headerlink" title="1. 代码表示"></a>1. 代码表示</h2><p>要想把文本中的某个部分以代码的形式表示出来，需要在文本的前后添加各一个反引号<code>`</code>使其被包裹起来。当部分其中本身含有反引号时，则需要前后各添加两个反引号来进行包裹。</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`markdown`</span>是一种轻量级的标记语言</span><br></pre></td></tr></table></figure></div>

<p>效果如下：</p>
<p><code>markdown</code>是一种轻量级的标记语言</p>
<p>而想要把代码块给整段以代码形式表现出来，可以采用围栏式代码块的方式来实现。将需要被代码表示的代码块的前后分别用三个反引号<code>```</code>将代码块给包裹起来，可以在代码块前的反引号后通过指定代码的语言类型来实现代码的语法高亮。</p>
<p>比如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(String fileName, File dir)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dir != <span class="literal">null</span> &amp;&amp; dir.isDirectory()) &#123;</span><br><span class="line">        <span class="comment">//得到所有的一级文件对象</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="comment">//遍历当前文件夹内的所有文件和文件夹</span></span><br><span class="line">                <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                    <span class="comment">//如果找到的是文件</span></span><br><span class="line">                    <span class="keyword">if</span> (file.getName().equals(fileName)) &#123;</span><br><span class="line">                        <span class="comment">//判断找到的文件名与要查找的文件名是否一致</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;所查找的文件路径为：&quot;</span> + file.getAbsolutePath());</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                            <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                            p = r.exec(file.getAbsolutePath());<span class="comment">//启动程序</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    searchFile(fileName, file);<span class="comment">//如果找到的是文件夹，则继续递归,从当前文件夹开始继续查找</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前位置不是文件夹&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-添加链接"><a href="#2-添加链接" class="headerlink" title="2. 添加链接"></a>2. 添加链接</h2><p>如果要在文本中添加一段内含链接的链接文本，则需要在前后依次添加一对中括号<code>[]</code>和圆括号<code>()</code>，中括号填入显示的链接文本的内容，圆括号内填入内含的链接，链接后面还可以选择是否带上双引号<code>&quot;</code>包裹的title，title能够在使鼠标悬置在链接文本上时显示。比如要嵌入google的链接到文本中，则写法为：</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">google</span>](<span class="link">https://www.google.com &quot;title&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>效果如下：</p>
<p><a class="link"   href="https://www.google.com/"  title="title">google <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>而如果想直接嵌入可点击的链接，只需要使用尖括号<code>&lt;&gt;</code>将链接包裹起来即可。</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">&lt;https://www.google.com&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>效果如下：</p>
<p><a class="link"   href="https://www.google.com/" >https://www.google.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="3-插入图片"><a href="#3-插入图片" class="headerlink" title="3. 插入图片"></a>3. 插入图片</h2><p>图片插入和链接嵌入的方法类似，只需要在中括号前额外添加一个感叹号<code>!</code>，然后在中括号内写入Alt标签（可以不写），并圆括号内添加图片链接，其中图片链接可以为本地图片，支持填入对应的绝对路径或相对路径，也可以是网络图片，填入对应的网络链接即可。同样链接后可以选择是否填入图片的title。</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">images/markdown-2/pic1.jpg</span>)</span><br></pre></td></tr></table></figure></div>

<p>效果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/markdown-2/pic1.jpg"
                     
                ></p>
<p>而如果要让图片并排显示，则对应的markdown写法为：</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">images/markdown-2/pic2.jpg</span>) | ![](<span class="link">images/markdown-2/pic3.jpg</span>)</span><br><span class="line">---|---</span><br></pre></td></tr></table></figure></div>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/markdown-2/pic2.jpg"
                     
                ></th>
<th><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/markdown-2/pic3.jpg"
                     
                ></th>
</tr>
</thead>
</table>
<h2 id="4-表格语法"><a href="#4-表格语法" class="headerlink" title="4. 表格语法"></a>4. 表格语法</h2><p>要在文章中添加表格，应该使用三个或以上连字符（减号）<code>-</code>作为每列标题的底，并以分隔符<code>|</code>来分隔每列，在编写时单元格不需要完全一致对齐。写法举例：</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">| 姓名 | 年龄  | 性别 | </span><br><span class="line">| --- |-----|-----|</span><br><span class="line">| A  | 20  | M   |</span><br><span class="line">| B  |  19  |  F  |</span><br><span class="line">|  C |  22 |  F  |</span><br></pre></td></tr></table></figure></div>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>年龄</th>
<th>性别</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>20</td>
<td>M</td>
</tr>
<tr>
<td>B</td>
<td>19</td>
<td>F</td>
</tr>
<tr>
<td>C</td>
<td>22</td>
<td>F</td>
</tr>
</tbody></table>
<p>而如果分别在标题下连字符的左侧、右侧和两侧添加冒号<code>:</code>，则会使文本对齐到表格左侧、右侧和中间。</p>
<h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h2><p>如果要使文章缩略展示，需要在被缩略的文本前添加上<code>&lt;!--more--&gt;</code>，这样只有在点开全文内容时被缩略文本才会显示出来。</p>
<p>对于一些被用在markdown语法上的符号，如果要把这些符号本身给显示出来，需要在符号前添加上反斜杠<code>\</code>。</p>
<p>而要想在文本中添加删除线，则要在目标文本前后各添加两个波浪号<code>~~</code>。</p>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个~~错误信息~~</span><br></pre></td></tr></table></figure></div>

<p>效果如下：</p>
<p>这是一个<del>错误信息</del></p>
<p>此外，markdown完全支持HTML和CSS格式编写，其在插入图片、嵌入链接、调整字体颜色等方面都能够和markdown进行配合使用。比如直接添加：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>这是一段红色文本<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>效果即为：</p>
<p><font color="red">这是一段红色文本</font></p>
<p>另外，在hexo中还可以安装Mermaid JS模块，用来画流程图。</p>
<pre class="mermaid">    graph TD;
      client1 <--> proxy
      client2 <--> proxy
      client3 <--> proxy
      proxy <--> server</pre>

<p>其中，graph 类型可以是 graph、digraph、flowchart、gantt、sequenceDiagram、classDiagram 和 stateDiagram。</p>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
